@using ClassicGames.Engine
@inject IJSRuntime JS

<div class="game-container">
    <div class="game-header">
        <a href="/" class="back-button">‚Üê Back to Games</a>
        <h2>@GameTitle</h2>
        <div class="settings">
            <label class="toggle-label">
                <input type="checkbox" @bind="slowPrintEnabled" @bind:event="onchange" @bind:after="OnSlowPrintChanged" />
                <span>Slow Print</span>
            </label>
        </div>
    </div>

    <div class="game-output" @ref="outputDiv">
        @for (int i = 0; i < outputLines.Count; i++)
        {
            var needsAnimation = slowPrintEnabled && i >= animateFromIndex && animateFromIndex >= 0;
            <div data-line-index="@i" class="@(needsAnimation ? "needs-typewriter" : "")">@outputLines[i]</div>
        }
    </div>

    @if (needsInput && !gameOver)
    {
        <div class="game-input">
            <span class="prompt">@currentPrompt</span>
            <input @ref="inputElement"
                   value="@currentInput"
                   @onkeydown="HandleKeyDown"
                   @oninput="HandleInput"
                   type="text"
                   maxlength="@(isSingleChar ? 1 : 100)"
                   autofocus />
        </div>
    }

    @if (gameOver)
    {
        <div class="game-over">
            <button @onclick="RestartGame" class="restart-button">Play Again</button>
            <a href="/" class="home-button">Back to Games</a>
        </div>
    }
</div>

@code {
    [Parameter]
    public string GameTitle { get; set; } = "Game";

    [Parameter]
    public GameEngine? Game { get; set; }

    private List<string> outputLines = new();
    private int animateFromIndex = -1;
    private string currentInput = "";
    private string currentPrompt = "> ";
    private bool needsInput = true;
    private bool gameOver = false;
    private bool isSingleChar = false;
    private bool slowPrintEnabled = false;
    private ElementReference inputElement;
    private ElementReference outputDiv;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Load slow print preference from localStorage
            try
            {
                slowPrintEnabled = await JS.InvokeAsync<bool>("loadSlowPrintPreference");
                StateHasChanged();
            }
            catch
            {
                // Default to false if localStorage not available
            }

            if (Game != null)
            {
                ProcessGameOutput(Game.ProcessInput(""));
                StateHasChanged();
                await FocusInput();
            }
        }

        await ScrollToBottom();
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && Game != null && !isSingleChar)
        {
            await SubmitInput();
        }
    }

    private async Task HandleInput(ChangeEventArgs e)
    {
        currentInput = e.Value?.ToString() ?? "";

        // Auto-submit for single character mode
        if (isSingleChar && currentInput.Length > 0 && Game != null)
        {
            await SubmitInput();
        }
    }

    private async Task SubmitInput()
    {
        if (Game == null) return;

        var input = currentInput;
        outputLines.Add($"{currentPrompt}{input}");
        currentInput = "";

        var result = Game.ProcessInput(input);
        ProcessGameOutput(result);

        StateHasChanged();

        // Manually clear the input field for single char mode
        if (isSingleChar)
        {
            await ClearInputField();
        }

        await FocusInput();
    }

    private void ProcessGameOutput(Engine.StateResult result)
    {
        bool shouldAnimate = false;
        if (result.Output != null && result.Output.Count > 0)
        {
            if (slowPrintEnabled)
            {
                animateFromIndex = outputLines.Count;
                shouldAnimate = true;
            }
            outputLines.AddRange(result.Output);
        }

        // Check if game is over by looking at state name or output
        var lastOutput = result.Output != null && result.Output.Count > 0
            ? string.Join(" ", result.Output)
            : "";

        if (lastOutput.Contains("Thanks for playing", StringComparison.OrdinalIgnoreCase) ||
            result.NextState == "GAME_OVER")
        {
            gameOver = true;
            needsInput = false;
            return;
        }

        // Check if current state needs input
        if (Game != null)
        {
            var inputSpec = Game.GetCurrentInputSpec();
            if (inputSpec?.Mode == Engine.InputMode.None)
            {
                // Auto-advance states that don't need input
                needsInput = false;

                // Animate lines if slow print is enabled, then auto-advance
                if (shouldAnimate)
                {
                    StateHasChanged();
                    _ = AnimateAndAdvance();
                }
                else
                {
                    var nextResult = Game.ProcessInput("");
                    ProcessGameOutput(nextResult);
                }
            }
            else
            {
                // Update prompt and show input
                needsInput = true;
                isSingleChar = inputSpec?.Mode == Engine.InputMode.SingleChar;
                currentPrompt = inputSpec?.Prompt ?? "> ";

                // Animate new lines if slow print is enabled
                if (shouldAnimate)
                {
                    StateHasChanged();
                    _ = AnimateNewLinesAndRestoreFocus();
                }
            }
        }
    }

    private async Task AnimateAndAdvance()
    {
        await Task.Delay(50); // Give DOM time to render
        await AnimateNewLines();
        if (Game != null)
        {
            var nextResult = Game.ProcessInput("");
            ProcessGameOutput(nextResult);
        }
    }

    private void RestartGame()
    {
        outputLines.Clear();
        currentInput = "";
        gameOver = false;
        needsInput = true;

        if (Game != null)
        {
            // Recreate the game - child component will handle this
            OnRestart.InvokeAsync();
        }
    }

    [Parameter]
    public EventCallback OnRestart { get; set; }

    private async Task FocusInput()
    {
        try
        {
            await inputElement.FocusAsync();
        }
        catch
        {
            // Input element might not be rendered yet
        }
    }

    private async Task ScrollToBottom()
    {
        try
        {
            await JS.InvokeVoidAsync("eval", "document.querySelector('.game-output').scrollTop = document.querySelector('.game-output').scrollHeight");
        }
        catch
        {
            // Scrolling is optional
        }
    }

    private async Task ClearInputField()
    {
        try
        {
            await JS.InvokeVoidAsync("eval", "document.querySelector('.game-input input').value = ''");
        }
        catch
        {
            // Clearing is optional
        }
    }

    private async Task AnimateNewLines()
    {
        try
        {
            await Task.Delay(50); // Give DOM time to render
            await JS.InvokeVoidAsync("animateTypewriter");
        }
        catch
        {
            // Animation is optional
        }
    }

    private async Task AnimateNewLinesAndRestoreFocus()
    {
        try
        {
            await Task.Delay(50); // Give DOM time to render
            await FocusInput(); // Restore focus immediately
            await JS.InvokeVoidAsync("animateTypewriter");
        }
        catch
        {
            // Animation is optional
        }
    }

    private async Task OnSlowPrintChanged()
    {
        try
        {
            await JS.InvokeVoidAsync("saveSlowPrintPreference", slowPrintEnabled);
        }
        catch
        {
            // localStorage save is optional
        }
    }
}

<style>
    .game-container {
        max-width: 900px;
        margin: 0 auto;
        padding: 1rem;
        height: 100vh;
        display: flex;
        flex-direction: column;
    }

    .game-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
        padding-bottom: 1rem;
        border-bottom: 1px solid #003300;
        gap: 1rem;
    }

    .settings {
        display: flex;
        align-items: center;
    }

    .toggle-label {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        color: #00aa00;
        cursor: pointer;
        font-size: 0.9rem;
    }

    .toggle-label input[type="checkbox"] {
        cursor: pointer;
    }

    .toggle-label:hover {
        color: #00ff00;
    }

    .back-button {
        color: #00ff00;
        text-decoration: none;
        padding: 0.5rem 1rem;
        border: 1px solid #00ff00;
        border-radius: 4px;
        transition: background 0.2s;
    }

    .back-button:hover {
        background: #003300;
    }

    .game-header h2 {
        margin: 0;
        color: #00ff00;
    }

    .game-output {
        flex: 1;
        overflow-y: auto;
        padding: 1rem;
        background: #0a0a0a;
        border: 1px solid #003300;
        border-radius: 4px;
        margin-bottom: 1rem;
        line-height: 1.5;
        font-family: 'Courier New', monospace;
        white-space: pre-wrap;
    }

    .game-output div {
        margin: 0.25rem 0;
    }

    .game-output div.needs-typewriter {
        visibility: hidden;
    }

    .game-input {
        display: flex;
        align-items: center;
        padding: 1rem;
        background: #0a0a0a;
        border: 1px solid #003300;
        border-radius: 4px;
    }

    .prompt {
        color: #00ff00;
        margin-right: 0.5rem;
    }

    .game-input input {
        flex: 1;
        background: transparent;
        border: none;
        color: #00ff00;
        font-family: 'Courier New', monospace;
        font-size: 1rem;
        outline: none;
    }

    .game-over {
        text-align: center;
        padding: 1rem;
    }

    .restart-button, .home-button {
        margin: 0.5rem;
        padding: 0.75rem 1.5rem;
        border-radius: 4px;
        font-family: 'Courier New', monospace;
        font-weight: bold;
        cursor: pointer;
        text-decoration: none;
        display: inline-block;
    }

    .restart-button {
        background: #00ff00;
        color: #000;
        border: none;
    }

    .restart-button:hover {
        background: #00cc00;
    }

    .home-button {
        background: transparent;
        color: #00ff00;
        border: 1px solid #00ff00;
    }

    .home-button:hover {
        background: #003300;
    }
</style>
